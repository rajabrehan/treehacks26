-- OpenLobby initial schema
-- Apply via Supabase CLI: supabase db reset / supabase db push

create extension if not exists "pgcrypto";

-- Canonical entities
create table if not exists public.entities (
  id text primary key,
  type text not null check (type in ('politician','company','pac','lobbyist','bill','document')),
  name text not null,
  description text,
  party text,
  state text,
  industry text,
  total_lobbying numeric,
  total_donations numeric,
  metadata jsonb not null default '{}'::jsonb,
  last_updated timestamptz not null default now()
);

create index if not exists entities_type_idx on public.entities(type);

-- Canonical relationships
create table if not exists public.relationships (
  id text primary key,
  type text not null check (type in ('donation','lobbying','vote','employment')),
  source_id text not null references public.entities(id) on delete cascade,
  target_id text not null references public.entities(id) on delete cascade,
  amount numeric,
  date date,
  cycle text,
  description text,
  metadata jsonb not null default '{}'::jsonb,
  last_updated timestamptz not null default now()
);

create index if not exists relationships_source_id_idx on public.relationships(source_id);
create index if not exists relationships_target_id_idx on public.relationships(target_id);

-- Canonical documents (news/articles/filings summaries etc.)
create table if not exists public.documents (
  id text primary key, -- stable id generated by backend (sha prefix)
  source text not null, -- e.g. 'news', 'sec_edgar', 'fec', 'lda_senate'
  url text,
  title text not null,
  published_at timestamptz,
  excerpt text,
  image_url text,
  entities_mentioned text[] not null default '{}'::text[],
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create unique index if not exists documents_url_unique_idx on public.documents(url) where url is not null;
create index if not exists documents_published_at_idx on public.documents(published_at desc);

-- Curated narratives for landing scrollytelling (generated dynamically, stored canonically)
create table if not exists public.case_files (
  id text primary key, -- stable slug, e.g. 'drug-pricing'
  title text not null,
  dek text,
  hero_image_url text,
  tags text[] not null default '{}'::text[],
  steps jsonb not null, -- ordered array consumed by frontend
  entities_featured text[] not null default '{}'::text[],
  updated_at timestamptz not null default now()
);

-- User tables (Supabase Auth + RLS)
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  avatar_url text,
  created_at timestamptz not null default now()
);

create table if not exists public.saved_queries (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  query text not null,
  created_at timestamptz not null default now()
);

create table if not exists public.bookmarks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  entity_id text not null references public.entities(id) on delete cascade,
  note text,
  created_at timestamptz not null default now(),
  unique (user_id, entity_id)
);

alter table public.profiles enable row level security;
alter table public.saved_queries enable row level security;
alter table public.bookmarks enable row level security;

-- RLS policies (owner-only)
drop policy if exists "profiles_owner_read" on public.profiles;
create policy "profiles_owner_read" on public.profiles
  for select using (auth.uid() = user_id);

drop policy if exists "profiles_owner_write" on public.profiles;
create policy "profiles_owner_write" on public.profiles
  for insert with check (auth.uid() = user_id);

drop policy if exists "profiles_owner_update" on public.profiles;
create policy "profiles_owner_update" on public.profiles
  for update using (auth.uid() = user_id);

drop policy if exists "saved_queries_owner" on public.saved_queries;
create policy "saved_queries_owner" on public.saved_queries
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

drop policy if exists "bookmarks_owner" on public.bookmarks;
create policy "bookmarks_owner" on public.bookmarks
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

